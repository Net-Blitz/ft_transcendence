{"ast":null,"code":"import { getMimeType } from './utils/mime-type.js';\nimport { ensureSize } from './utils/svg.js';\nimport { getEncoder } from './utils/text.js';\nexport const toFormat = function (svg, format, exif) {\n  return {\n    toDataUri: () => toDataUri(svg, format, exif),\n    toFile: name => toFile(name, svg, format, exif),\n    toArrayBuffer: () => toArrayBuffer(svg, format, exif)\n  };\n};\nasync function toDataUri(svg, format, exif) {\n  if ('svg' === format) {\n    return `data:${getMimeType(format)};utf8,${encodeURIComponent(svg)}`;\n  }\n  const canvas = await toCanvas(svg, format, exif);\n  return canvas.toDataURL(getMimeType(format));\n}\nasync function toArrayBuffer(rawSvg, format, exif) {\n  if ('svg' === format) {\n    return getEncoder().encode(rawSvg);\n  }\n  const canvas = await toCanvas(rawSvg, format, exif);\n  return await new Promise((resolve, reject) => {\n    canvas.toBlob(blob => {\n      blob ? resolve(blob.arrayBuffer()) : reject(new Error('Could not create blob'));\n    }, getMimeType(format));\n  });\n}\nasync function toFile(name, svg, format, exif) {\n  const link = document.createElement('a');\n  link.href = await toDataUri(svg, format, exif);\n  link.download = name;\n  link.click();\n  link.remove();\n}\nasync function toCanvas(rawSvg, format, exif) {\n  if (exif) {\n    console.warn('The `exif` option is not supported in the browser version of `@dicebear/converter`. \\n' + 'Please use the node version of `@dicebear/converter` to generate images with exif data.');\n  }\n  let {\n    svg,\n    size\n  } = ensureSize(rawSvg);\n  const canvas = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n  const context = canvas.getContext('2d');\n  if (null === context) {\n    throw new Error('Could not get canvas context');\n  }\n  if (format === 'jpeg') {\n    context.fillStyle = 'white';\n    context.fillRect(0, 0, size, size);\n  }\n  var img = document.createElement('img');\n  img.width = size;\n  img.height = size;\n  img.setAttribute('src', await toDataUri(svg, 'svg'));\n  return new Promise((resolve, reject) => {\n    img.onload = () => {\n      context.drawImage(img, 0, 0, size, size);\n      resolve(canvas);\n    };\n    img.onerror = e => reject(e);\n  });\n}","map":{"version":3,"names":["getMimeType","ensureSize","getEncoder","toFormat","svg","format","exif","toDataUri","toFile","name","toArrayBuffer","encodeURIComponent","canvas","toCanvas","toDataURL","rawSvg","encode","Promise","resolve","reject","toBlob","blob","arrayBuffer","Error","link","document","createElement","href","download","click","remove","console","warn","size","width","height","context","getContext","fillStyle","fillRect","img","setAttribute","onload","drawImage","onerror","e"],"sources":["/app/node_modules/@dicebear/converter/lib/core.js"],"sourcesContent":["import { getMimeType } from './utils/mime-type.js';\nimport { ensureSize } from './utils/svg.js';\nimport { getEncoder } from './utils/text.js';\nexport const toFormat = function (svg, format, exif) {\n    return {\n        toDataUri: () => toDataUri(svg, format, exif),\n        toFile: (name) => toFile(name, svg, format, exif),\n        toArrayBuffer: () => toArrayBuffer(svg, format, exif),\n    };\n};\nasync function toDataUri(svg, format, exif) {\n    if ('svg' === format) {\n        return `data:${getMimeType(format)};utf8,${encodeURIComponent(svg)}`;\n    }\n    const canvas = await toCanvas(svg, format, exif);\n    return canvas.toDataURL(getMimeType(format));\n}\nasync function toArrayBuffer(rawSvg, format, exif) {\n    if ('svg' === format) {\n        return getEncoder().encode(rawSvg);\n    }\n    const canvas = await toCanvas(rawSvg, format, exif);\n    return await new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n            blob\n                ? resolve(blob.arrayBuffer())\n                : reject(new Error('Could not create blob'));\n        }, getMimeType(format));\n    });\n}\nasync function toFile(name, svg, format, exif) {\n    const link = document.createElement('a');\n    link.href = await toDataUri(svg, format, exif);\n    link.download = name;\n    link.click();\n    link.remove();\n}\nasync function toCanvas(rawSvg, format, exif) {\n    if (exif) {\n        console.warn('The `exif` option is not supported in the browser version of `@dicebear/converter`. \\n' +\n            'Please use the node version of `@dicebear/converter` to generate images with exif data.');\n    }\n    let { svg, size } = ensureSize(rawSvg);\n    const canvas = document.createElement('canvas');\n    canvas.width = size;\n    canvas.height = size;\n    const context = canvas.getContext('2d');\n    if (null === context) {\n        throw new Error('Could not get canvas context');\n    }\n    if (format === 'jpeg') {\n        context.fillStyle = 'white';\n        context.fillRect(0, 0, size, size);\n    }\n    var img = document.createElement('img');\n    img.width = size;\n    img.height = size;\n    img.setAttribute('src', await toDataUri(svg, 'svg'));\n    return new Promise((resolve, reject) => {\n        img.onload = () => {\n            context.drawImage(img, 0, 0, size, size);\n            resolve(canvas);\n        };\n        img.onerror = (e) => reject(e);\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}